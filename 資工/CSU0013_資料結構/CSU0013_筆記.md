# 吐司寫筆記：資料結構筆記  
[![hackmd-github-sync-badge](https://hackmd.io/iGPiM7jrQUiX1mMdvMS1mA/badge)](https://hackmd.io/iGPiM7jrQUiX1mMdvMS1mA)  

**topic: `大學課程` `筆記`**  
  
一段期中的內容難易度無須製作筆記，所以我沒做。  

為了觀看體驗，建議可以前往我的 [HackMD](https://hackmd.io/iGPiM7jrQUiX1mMdvMS1mA) 觀看筆記  

## Tree  
![image](https://hackmd.io/_uploads/rkMP7mUzyg.png)
### Formal Definition of Trees  
- A tree is a **final set of one or more nodes**  
- There is a specially designated node: the **root node**  
- Every node in the tree is the root node of some **subtree**  
### Terminology Definitions  
![image](https://hackmd.io/_uploads/rkUmNQIGJx.png)

- **Edge** : the side connect node and node  
- **Root** : the top node of the tree  
- **Parent** : X is parent of its children  
- **Children** : the nodes in subtree which root node is X and connect X directly.  
- **Terminal nodes(leaf node, external node)** : nodes that have degree zero  
- **Nonterminal nodes(internal node)** : nodes that don't belog to terminal nodes  
- **Sliblings** : children of the same parent are said to be siblings  
- **Ancestors** : all the nodes along the path from the root to that node  
- **Descendants** : all the nodes in the subtree which root is the node.  
- **Depth(height)** : the maximum level of any node in the tree  
- **Degree** : the number of substree of a node  
- **Degree of a tree** : the maximum degree of the nodes in the tree  

### Tree Representations  
- Graph Representaion  

![image](https://hackmd.io/_uploads/H1WtGNUGJg.png)

- List Representation  

![image](https://hackmd.io/_uploads/H1TDfELGkl.png)


### Left Child-Right Sibling Representation  

- **Target** : reduce degree of tree  
- **Method** : connect the **right siblings** of the node and cut the edges connecting siblings to parent off  
- **Result** : all trees can became **binary trees** by this method  

![image](https://hackmd.io/_uploads/Syye8VLzJl.png)

## Binary Tree  

### Definition  
- Any node can have **at most 2 branches**  
- Every substree in binary tree is also binary tree  
    - call **left subtree** and **right subtree**  

![image](https://hackmd.io/_uploads/BJAKP4Iz1g.png)

### Special Binary Trees  
#### Skewed tree  
- Tree is slanted to one side, only one leaf node  
- Like a linked list  
- Have worse complexity  

![image](https://hackmd.io/_uploads/H1VJFELMJg.png)

#### Complete binary tree  
- Let binary tree have $n level$  
- Nodes up to level $n-1$ all exist ($2^n-1$ nodes)  
- Nodes at level $n$ exist in order from left to right  

![image](https://hackmd.io/_uploads/Bkpyn4UMkg.png)

#### Full Binary Tree  
- Let binary tree $depth = k$  
- A full binary tree has $2^k-1$ nodes  

![image](https://hackmd.io/_uploads/rJ9xTN8Gye.png)

### Properties of Binary Tree  
- Maximum number of nodes on **level i** : $2^{i-1}$  
- Maximum number of nodes in a **binary tree of depth k** : $2^k-1$  
- **the number of leaf nodes and the number of degree-2 nodes**  
    - let $n_0$ is number of leaf nodes, $n_2$ is number of number of degree 2  
    - then $n_0=n_2+1$
    - prove : 
    $\begin{align*}
        edge &= node - 1 \\
        1  \times n_1 + 2 \times n_2 &= n_0 + n_1 + n_2 + 1 \\
        n_2 &= n_0 - 1
    \end{align*}$
    
![image](https://hackmd.io/_uploads/HJVdZHIf1l.png)

### Array Representation  
#### Format  
We can represent a complete binary tree sequentially, than for any node with index $i$, $1 <= i <= n$, we have :  
- Parent(i) has index $\lfloor i/2 \rfloor$, if $i \ge 2$  
- LeftChild(i) has index $2i$, if $2i \le n$  
- RightChild(i) has index $2i + 1$, if $2i + 1 \le n$  

![image](https://hackmd.io/_uploads/B17mVH8zyg.png)  
![image](https://hackmd.io/_uploads/B1bV4S8GJg.png)  

#### Problem  
- **Worse case** : a **skewed tree** of depth $k$ requires $2^k-1$ space but only use $k$ spaces  
- It is hard to visualize  
- Insertion or deletion of nodes from the middle of a tree have large time complexity  

![image](https://hackmd.io/_uploads/rkolBBIGyl.png)  

### Linked List Representation  
#### Format  
```c!=
typedef struct _treePointer{
    int data;
    treePointer leftChild, rightChild;
}treePointer;
```
![image](https://hackmd.io/_uploads/B1seDHUG1l.png)
![image](https://hackmd.io/_uploads/SyfzPB8zkg.png)

### Binary Tree Traversals  
#### Depth first traversals  
- **V**LR(preorder)  
- L**V**R(inorder)  
- LR**V**(postorder)  
![image](https://hackmd.io/_uploads/ryDNRSIzye.png)

#### Breadth first traversak  
- Level order travelsal  

#### Example : arithmetic expression  
![image](https://hackmd.io/_uploads/HyxsAH8M1g.png)
- **Inorder travel (infix expression)** : A / B * C * D + E  
```c= !
void inorder(treePointer ptr){
    if(ptr){
        inorder(ptr->leftChild);   // L
        printf("%d", ptr->data);   // V
        inorder(ptr->rightChild);  // R
    }
    return;
}
```
- **preorder travel (prefix expression)** : + * * / A B C D E  
```c= !
void preorder(treePointer ptr){
    if(ptr){
        printf("%d", ptr->data);    // V
        preorder(ptr->leftChild);   // L
        preorder(ptr->rightChild);  // R
    }
    return;
}
```
- **postorder traversal (postfix expression)** : A B / C * D * E +  
```c= !
void postorder(treePointer ptr){
    if(ptr){
        postorder(ptr->leftChild);   // L
        postorder(ptr->rightChild);  // R
        printf("%d", ptr->data);     // V
    }
    return;
}
```
- **level order traversal** : + * E * D / C A B  
```cpp= !
void levelOrder(treePointer ptr){
    int front = rear = 0;
    treePointer queue[MAX_QUEUE_SIZE]; // queue
    
    if(!ptr) return;
    
    pushq(front, &rear, ptr);
    
    while(1){
        // FIFO
        ptr = popq(&front, rear);
        
        if(ptr){
            printf("%d", ptr->data);
            
            if(ptr->leftChild){
                pushq(front, &rear, ptr->leftChild);
            }
            
            if(ptr->rightChild){
                pushq(front, &rear, ptr->rightChild);
            }
        }else{
            break;
        }
    }
}
```
### Copying Binary Tree  
```c= !
treePointer copy(treePointer original){
    treePointer temp;
    
    if(original){
        malloc(temp * sizeof(*temp));
        temp->leftChild = copy(original->leftChild);
        temp->rightChild = copy(original->rightChild);
        temp->data = original->data;
        return temp;
    }
    
    return NULL;
}
```

### Testing for Equivalent Trees  
```c= !
int equal(treePointer first, treePointer second){
    // both of first and second are NULL
    if(!first && !second)return 1;
    
    // both of first and second are not NULL
    if(first->data == second->data && 
      equal(first->left, second->left) &&
      equal(first->right, second->right))return 1;
    
    // else
    return 0;
}
```

### Propositional Calculus Expression  
- **Boolean Variable** : **true** or **false** only  
- **Logical Operators** : $\land$(and), $\lor$(or), $\lnot$(not)  

![image](https://hackmd.io/_uploads/HyHw0LIMkl.png)

#### Structure  
![image](https://hackmd.io/_uploads/H1VQVPUGkg.png)
```c= !
typedef enum {not, and, or, true, false} logical;

typedef struct _treePointer{
    logical data;
    short int value;
    treePointer leftChild, rightChild;
}treePointer;
```

#### Evaluation  
- Use **postorder traversal** to evaluate expression  

![image](https://hackmd.io/_uploads/ryrltvIGye.png)

```c= !
void postOrderEval(treePointer node){
    
    if(node){
        postOrderEval(node->leftChild);  // L
        postOrderEval(node->rightChild); // R
        switch(node->data){              // V
            case not:  // not's child must be its right child
                node->value = !node->rightChild->value;
                break;
            case and:
                node->value = node->rightChild->value && node->leftChild->value;
                break;
            case or:
                node->value = node->rightChild->value || node->leftChild->value;
                break;
            case true:
                node->value = true;
                break;
            case false:
                node->value = false;
                break;
        }
    }
    
    return;
}
```

## Threaded Binary Trees  

- **Target** : replace null pointers with useful **threads**  

### Definition  

- Make **null left child pointer** points to the **inorder predecessor** of the node  
- Make **null right child pointer** points to the **inorder successor** of the node  

![image](https://hackmd.io/_uploads/HyIvcv8M1g.png)
(**Inorder** : A B C D E F G)  

- It make it possible to traverse the values in the binary tree via a **linear traversal**  
- more rapid than a recursive inorder traversal  

### Implementation Considerations  
- Two additional boolean fields in the node structure  
    - if **true** : contain a thread  
    - if **false** : points to the child  

![image](https://hackmd.io/_uploads/Hk7FnPIMkl.png)

```c= !
typedef struct _threadPointer{
    boolean leftThread, rightThread;
    threadPointer leftChild, rightChild;
    char data;
}threadPointer;
```

#### Example  
![image](https://hackmd.io/_uploads/SyS40vUMkg.png)

### Virtual Root Node  
- Create a **virtual root node**  
- assign (2) **dangling pointers** to point to this root node  

![image](https://hackmd.io/_uploads/ryV3l_8zkl.png)

### Inorder Traversal of Threaded Binary Tree  
- Time Complexity : **O(n)**  
- Without **stack** to store nodes  
```c= !
threadPointer insucc(threadedPointer tree){
    threadedPointer temp;
    temp = tree->rightChild;
    
    if(!tree->rightThread){ // 先向右，然後一路向左
        while(!temp->leftThread){
            temp = temp->leftChild;
        }
    }
    
    return temp
}

void tinorder(threadedPointer tree){
    /* traverse the threaded binary tree inorder */
    threadedPointer temp = tree;
    
    while(1){
        temp = insucc(temp);
        if(temp == tree)break;
        printf("%3c", temp->data)
    }
    
    return;
}
```

### Insertion  
![image](https://hackmd.io/_uploads/rJKm5d8zJl.png)

- Insert new node r as a right child of node s  
```c= !
void insert_right(threadPointer s, threadedPointer r){
    threadedPointer temp;
    
    r->rightChild = s->rightChild;
    r->rightThread = s->rightThread;
    
    r->leftChild = s;
    r->leftThread = true;
    
    s->rightChild = r;
    s->rightThread = false;
    
    if(r->rightThread){
        temp = insucc(r);
        temp->leftChild = r;
    }
    
    return;
}
```
